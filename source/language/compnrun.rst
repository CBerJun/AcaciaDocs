编译和运行模型
================

对象和数据类型
----------------

Acacia 中的各种数据被称作 :dfn:`对象`\ 。任何一个表达式都表示一个对象。每个对象都拥有数据类型，数据类型是不能被改变的。每个对象还可拥有属性，可通过 ``.`` 分隔符访问。

编译时和运行时
----------------

Acacia 代码会经历 2 个阶段，即 :dfn:`编译时` 和 :dfn:`运行时`\ 。一段 Acacia 程序中往往同时包含在这两个不同阶段内执行的操作。它们是 Acacia 中\ **很重要**\ 的概念。

编译是指通过程序将 Acacia 代码转换为 Minecraft 命令的过程。Minecraft 显然看不懂 Acacia 代码，所以需要编译器程序将它转换为 Minecraft 可以看懂的命令。编译时的操作是由编译器完成的。

运行是指将编译器生成的代码加载入 Minecraft 世界中进行运行的过程。运行时的操作是由 Minecraft 完成的。

编译器内部表示各种值的东西叫做 :dfn:`内部对象`\ 。编译器的内部有符号表机制，它记录代码中所使用的各个标识符代表哪一个内部对象。

编译时的操作一般会修改内部对象，而运行时的操作不会修改内部对象。一些例子:

    * ``x = 42``\ （假如 ``x`` 是整数变量）是一个运行时操作，它告诉 Minecraft 把 ``x`` 设置为 42。所谓整数变量即\ **运行时我才知道它的值，编译时我不在乎也不知道它是几的整数**\ 。
    * ``x -> 42`` 是一个编译时操作，它把 ``x`` 关联的内部对象设置为一个值为 42 的编译时整数（所谓编译时整数即\ **编译时其值已知的整数**\ ）。
    * ``x: int`` 是一个编译时操作。它把 ``x`` 关联的内部对象设置为一个新的整数变量。
    * ``x: int = 42`` 既进行编译时操作，也做运行时操作。它先把 ``x`` 关联的内部对象设置为一个新的整数变量（编译时），然后告诉 Minecraft 把 ``x`` 设置为 42（运行时）。

说得更加透彻一些:

    * ``x -> y`` 在符号表里把 ``x`` 关联为 ``y`` 所指代的内部对象。
    * ``x = y`` 生成命令告诉 Minecraft 将变量 ``x`` 的值设置成 ``y``\ ，符号表没有变更。
    * ``x := y`` 和 ``x: t = y`` 生成了一个新的变量内部对象，接着把 ``x`` 关联到它，最后执行 ``x = y``\ 。

发现了吗？内部对象仅在编译器对其认知发生变化的时候才会变更。例如::

    x -> 10
    y := 10
    x -> 20
    y = 20

上例中 ``x`` 的内部对象从“值为 10 的编译时整数”变更为“值为 20 的编译时整数”，而 ``y`` 对于编译器始终是整数变量（编译器不在乎它的值）。

再看一个例子::

    p := 0
    q -> p
    r := p
    q = 5
    r += 10

思考一下，这个程序中创建了几个变量，\ ``p`` 指代的变量现在是什么值呢？分析一下:

    * 第 1 行，\ ``:=`` 新建了一个整数变量，让我们称其 X。\ ``p`` 被关联为“整数变量X”，并生成了一条将 X 设置为 0 的命令。目前 X 是 0。
    * 第 2 行，\ ``->`` 把 ``q`` 关联为 ``p`` 代表的内部变量，即 ``q`` 也被关联为“整数变量X”。
    * 第 3 行，\ ``:=`` 新建了一个整数变量，让我们称其 Y。\ ``r`` 被关联为“整数变量Y”，并生成了一条将 Y 设置为 ``p`` 代表的值（即 X）的命令。目前 X 和 Y 都是 0。
    * 第 4 行，\ ``q`` 所关联的变量（即 X 的值，也就是 0）被设置为 ``5``\ 。目前 X 为 5，Y 为 0。
    * 第 5 行，\ ``r`` 所关联的变量（即 Y）被增加了 ``10``\ 。目前 X 为 5，Y 为 10。

所以创建了 2 个变量，即 X 和 Y，\ ``p`` 所指变量（即 X）最后的值为 5。

意义
^^^^^^^^^^^^

所以，到底为什么要区分编译时整数和整数变量呢？

这是因为 Minecraft 指令提供的接口限制很大，不能做到一个可变的整数满地用。有一些地方我们在\ **编写命令时**\ 就必须给出整数的确切值，比如给予生物\ :mcwiki:`~状态效果`\ 时效果的持续时长和等级:

.. code-block:: mcfunction

    effect @a night_vision 9999 0

在上面的这条命令里 ``9999`` 是时长，\ ``0`` 是指 1 级。此处它们也必须是数字，意味着这条命令给予什么样等级和时长的效果，在编译器生成这条命令时（即编译时）就必须被确定，而不能是一个运行时的变量。所以，Acacia 中给予生物状态效果的函数必须接受编译时的整数作为效果等级和时长。

可存储和不可存储
--------------------

以下是另外一些内部对象的例子:

    * ``import math`` 中的 ``math`` 是一个模块。模块只以这种形式存在（不像整数有变量形式和编译时形式）。
    * ``"foo ${2+3}"`` 是一个值为 ``"foo 5"`` 的字符串。字符串也只以该形式存在。

为什么我们不在上面这些数据类型里区分编译时形式和变量呢？答案是它们无法拥有变量形式。\ ``x := "foo"`` 是不能编译通过的——如果说字符串存在变量形式，我们知道变量赋值是运行时的，因此需要我们在运行的时候存储 ``"foo"`` 这个字符串，然而在 Minecraft 中我们很难实现字符串的存储——所以字符串只存在于编译时。\ ``x -> "foo"`` 是合法的，因为 ``->`` 是一个编译时操作，编译器有能力存储字符串。

这些没有变量形式的数据类型，我们就称它是 :dfn:`不可存储` 的，反之，它就是 :dfn:`可存储` 的。模块、函数等也都是不可存储的，它们是 Acacia 中抽象出的概念，不存在于 Minecraft。而整数和布尔值可以在运行时被存储，所以是可存储类型。

内联/非内联函数
--------------------

有了上面这些知识，接着我们就可以解释内联函数和非内联函数到底有什么区别了。

非内联
^^^^^^^^^^^^^

非内联函数，即定义不包含 ``inline`` 关键字的函数，会在行为包里真正地生成一个文件来存储这个函数的内容。调用这个函数的时候，编译器会告诉 Minecraft 要使用这个文件。然而 Minecraft 里“调用”一个命令文件是无法传参数或返回值的，所以编译器必须生成这些沟通调用者和被调用者的命令。编译器约定，在调用一个文件时，调用者需要把参数的值都\ **存到某些确定的变量**\ 里，然后被调用者也会将返回值\ **存在某个确定的变量里**\ ，这样一来调用者和被调用者只要读取或写入这些确定的变量就可以沟通了。注意一个细节，“确定的\ **变量**\ 里”——变量是运行时的，所以非内联函数的参数和返回值必须要拥有变量形式，换而言之它们必须是可存储的。例如这段代码是无效的::

    def foo(x="foo"):
        pass  # Do something with `x`

其次，由于编译器需要约定好这些用于交互的变量是哪些变量，所以参数与返回值的类型必须明确告诉编译器，不可改变。

再次，运行时对变量的修改是以赋值完成的，所以参数和返回值是以赋值形式与调用者交互的。例如::

    import print
    def bar(x: int):
        x = 10  # not modifying `g`
        print.tell(print.format("%0", x))  # 10
    g: int = 5
    bar(g)
    print.tell(print.format("%0", g))  # 5

就像::

    import print
    x: int = 5
    y: int = x
    y = 10  # not modifying `x`
    print.tell(print.format("%0", y))  # 10
    print.tell(print.format("%0", x))  # 5

非内联函数里的 ``result`` 的内部对象，其实就是编译器约定好的那个用来存放返回值的变量，因此 ``result`` 只能被赋值，而不能被绑定（记得绑定是编译时会改变内部对象的操作吧），因为编译器已经约定好这个变量了。

内联
^^^^^^^^^^^^^

而内联函数，即定义包含 ``inline`` 关键字的函数，是会在调用时被编译器在编译时当场展开的。当一个内联函数被定义，其内容不会被解析。等到它被调用时，编译器会解析函数体并展开在调用处。举个例子，这段代码::

    x := 0
    inline def foo():
        x += 1
    foo()
    foo()

其实会被转换成这段代码::

    x := 0
    x += 1
    x += 1

``x += 1`` 的命令被生成了 2 次。如果调用更多次则每次调用都解析一次函数体并生成对应命令。

再举个例子，这段代码::

    inline def bar():
        "xx" + 1

可以被编译通过，即使字符串加整数操作是不合法的。这是因为 ``foo`` 没有被调用，它的函数体一次都不会被解析。

那么参数和返回值是如何处理的呢？由于展开内联函数是由编译器完成的编译时操作，我们可以使用编译时的操作——绑定。因此在内联函数里，参数与返回值是以绑定形式传递的。例如这段代码::

    inline def baz(arg1, arg2):
        arg1 += 1
        arg2 += 2
        result -> arg1
    t := baz(x, y) + 1
    baz(z, w)

会被转换成 [1]_::

    _temp_arg1 -> x  # argument binding
    _temp_arg2 -> y  # argument binding
    _temp_arg1 += 1
    _temp_arg2 += 2
    _temp_result -> _temp_arg1  # result binding
    t := _temp_result + 1
    _temp_arg1 -> z
    _temp_arg2 -> w
    _temp_arg1 += 1
    _temp_arg2 += 2
    _temp_result -> _temp_arg1

等价于::

    x += 1
    y += 2
    t := x + 1
    z += 1
    w += 2

这也解释了:

为什么内联函数可以不指定参数和返回值类型？
    因为参数和返回值使用绑定传递，一个符号绑定到任何表达式都是合法的（即使并不是所有情况下都合理），而不需要知道类型。指定类型只是告诉编译器做额外的检查，确保参数类型是预料之内的。例如::

        inline def f(x):
            result -> x + 3
        f("xxx")

    会导致在 ``x + 3`` 处报错，但如果给 ``x`` 限定为 ``int`` 类型，那么会在调用出直接报错参数类型错误。

为什么内联函数的 ``result`` 可以被绑定？
    因为返回值是以绑定的形式传递的。内联函数中的 ``result`` 在被代码定义之前是不存在于符号表的，不像在非内联函数里 ``result`` 的内部对象一定是编译器约定的变量。

为什么内联函数的参数和返回值可以是不可存储类型？
    还是因为绑定。绑定作为编译时操作可以操作不可存储类型的东西。

为什么有时候内联函数的参数无法被赋值？为什么内联函数可以更改传入的变量？
    仍旧是因为绑定。举个例子::

        inline def spam(x: int):
            x = 1
        v: int
        spam(v)  # OK
        spam(10)  # Error

    其实会被转换为 [1]_::

        v: int
        _temp_x -> v
        _temp_x = 1  # OK
        _temp_x -> 10
        _temp_x = 1  # Error

    也就等价于::

        v = 1  # OK
        10 = 1  # Error

    注意上面这个例子里，\ ``v`` 变量的值在调用 ``spam`` 时被改变了。也就是说内联函数由于它绑定的特性，可以在函数内修改传入变量的值。

.. [1]  这里的 :samp:`_temp_{xxx}` 形式的标识符只是为了展示内部原理，不会实际被创建。

比较
^^^^^^^^^^^^^

那么什么时候该用内联函数，什么时候该用非内联函数呢？

从上面的解释，我们不难知道它们各自的好处:

    * 非内联函数:

        - 函数体只解析一次，调用处多时每一处代码都可以较为精简（内联函数每次调用都要重新解析函数体，重新生成命令）。
        - 函数体得到的参数更加可控——它们都相当于编译器创建好的局部变量，对调用者不会有影响。

    * 内联函数:

        - 更加灵活——可以传输任何表达式作为参数和返回值。内联函数内部拥有传入参数的完全控制（如可以赋值）。
        - 函数交接时的开销更小，因为不会创建用于交接的变量。
