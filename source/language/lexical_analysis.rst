语言解析
==============

Acacia 程序编译的第一步是词法分析。词法分析器读入字符形式的程序（每个字符都对应一个 `Unicode 码点`_）并将其转换为一串 :dfn:`形符`\ （token）。

.. _Unicode 码点: https://www.unicode.org/versions/Unicode16.0.0/core-spec/chapter-3/#G22700


行结构
------------

一个 Acacia 程序由多个 :dfn:`逻辑行` 组成。

逻辑行
^^^^^^^^^^

一个逻辑行是由一个或多个 :dfn:`物理行` 通过续行而成的。

物理行
^^^^^^^^^^

一个物理行指源文件中的一串由换行符或文件结束结尾的一串字符。以下的字符序列均被认为是换行符:

* ``\n``
* ``\r\n``
* ``\r``

其中 ``\r`` 指的是 ASCII 码 ``0x0D`` 的“回车”字符（CR）；\ ``\n`` 指的是 ASCII 码 ``0x0A`` 的“换行”字符（LF）。

.. _comment:

注释
^^^^^^^^^^

Acacia 中有以下这些注释，它们会被编译器忽略:

* 由后面非 ``*`` 字符的 ``#`` 字符开始直至物理行结束的单行注释
* 由紧贴着的 ``#*`` 开始，由 ``*#`` 结束的多行注释

:ref:`命令 <command>`\ 或\ :ref:`字符串 <str-literal>`\ 中的 ``#`` 或 ``#*`` 不会被解读为注释。

显式续行
^^^^^^^^^^

若一个物理行的最后一个字符是 ``\``\ ，除非它在\ :ref:`注释 <comment>`\ 或\ :ref:`命令 <command>`\ 中，否则该行与下一行就会拼接为一个逻辑行::

    x = a_very_long_variable \
        + another_very_long_variable

此处拼接是形符层面的拼接，而不是字符层面的。例如::

    a := 1\
    0

是无效的，而不会被解释为 ``a := 10``\ 。

隐式续行
^^^^^^^^^^

``()``\ 、\ ``[]`` 以及 ``{}`` 之间的内容可以分成多个物理行::

    const month_names = {
        # 3-letter abbreviations of months
        "Jan", "Feb", "Mar",
        "Apr", "May", "Jun",
        "Jul", "Aug", "Sep",
        "Oct", "Nov", "Dec"
    }

它相比显式续行的好处在于可以添加注释，允许空白行。

隐式续行同样是形符层面的拼接。

缩进
^^^^^^^^^^

逻辑行开头的空格符用于计算该行的缩进层级，决定语句组块。制表符是不允许的。行的缩进层级以堆栈形式生成 ``INDENT`` 和 ``DEDENT`` 形符，说明如下。

读取文件第一行前，先向栈推入一个零值，该零值不会被移除。推入栈的层级值从底至顶持续增加。每个逻辑行开头的行缩进层级将与栈顶行比较。如果相等，则不做处理。如果新行层级较高，则会被推入栈顶，并生成一个 ``INDENT`` 形符。如果新行层级较低，则应当是栈中的层级数值之一；栈中高于该层级的所有数值都将被移除，每移除一级数值生成一个 ``DEDENT`` 形符。文件末尾，栈中剩余的每个大于零的数值生成一个 ``DEDENT`` 形符。

以下是一个正确缩进的例子::

    def is_prime(x: int) -> bool:
        #* Test if an integer is a prime number. `x` must be positive. *#
        if x == 1:
            return False
        mod := 2
        while mod <= x / 2:
            if x % mod == 0:
                return False
            mod += 1
        return True

空白行
^^^^^^^^^^

若一个逻辑行只由空白字符或注释组成而未曾产生过形符，则它是空白行，会被忽略，意味着其缩进不产生影响::

    if foo:
    # Not indented, but this is legal
        pass


形符的分隔
---------------------

除非在逻辑行的开始、\ :ref:`字符串 <str-literal>`\ 或\ :ref:`命令 <command>`\ 内，空格字符（ASCII 码 ``0x20``\ ）可以被用来分隔形符。

词法分析器总是会尝试为一个形符读取尽量多的字符，比如 ``abc`` 会被解读为一整个\ :ref:`标识符 <identifier-and-keyword>`\ ，而不是 ``a``\ ，\ ``b`` 和 ``c`` 三个形符。如果需要将相连的形符分开，则需要使用空格符。


.. _identifier-and-keyword:

标识符和关键字
---------------------

标识符是由一个或多个字符组成的字串。组成标识符的字符只能是下面这些:

* 下划线 ``_``
* Unicode 标准中被认为是“字母”的字符，即所有类别（\ `General Category`_\ ）为 Lu、Ll、Lt、Lm 或 Lo 的字符。
* ASCII 数字字符 ``0`` 至 ``9``

此外，第一个字符不能是数字字符。

Acacia 中的标识符是区分大小写的。

.. _General Category: https://www.unicode.org/glossary/#general_category

关键字
^^^^^^^^^^

以下标识符为 :dfn:`关键字`\ ，有特殊含义，必须按照语言标准规定的方式使用，否则编译器会报错:

.. hlist::
    :columns: 4

    * ``True``
    * ``def``
    * ``interface``
    * ``inline``
    * ``entity``
    * ``extends``
    * ``self``
    * ``if``
    * ``elif``
    * ``else``
    * ``while``
    * ``pass``
    * ``and``
    * ``or``
    * ``not``
    * ``return``
    * ``import``
    * ``as``
    * ``from``
    * ``None``
    * ``for``
    * ``in``
    * ``struct``
    * ``virtual``
    * ``override``
    * ``const``
    * ``static``
    * ``new``
    * ``False``

被保留的标识符
^^^^^^^^^^^^^^^^^

``__*__`` 形式的标识符是用于和语言核心交互的，各名称的含义由解释器和标准库定义。任何情况下不遵循文档的使用都可能在当前或未来的版本引起问题，且编译器不一定会报错。


字面值
---------------------

字面值是内置类型常量值的表示法。

整数字面值
^^^^^^^^^^^^^

Acacia 支持以下的整数字面值:

* 由一个或多个 ``0`` 至 ``9`` 数字字符组成的十进制数。以多余的 ``0`` 开头是允许的，会被忽略。
* 由 ``0x`` 或 ``0X`` 开头，加上一个或多个 ``0`` 至 ``9``\ 、\ ``a`` 至 ``f`` 或 ``A`` 至 ``F`` 字符组成的十六进制数。大小写没有区别。
* 由 ``0b`` 或 ``0B`` 开头，加上一个或多个 ``0`` 或 ``1`` 字符组成的二进制数。
* 由 ``0o`` 或 ``0O`` 开头，加上一个或多个 ``0`` 至 ``7`` 字符组成的八进制数。

整数字面值不能直接表示负数。\ ``-1`` 实际上是由一元运算符 ``-`` 与字面值 ``1`` 组合起来的。整数字面值的大小应当控制在 32 位有符号整数范围内，即最小 :math:`0`\ ，最大 :math:`2^{31} - 1`\ 。

示例::

    7
    103
    0b0001100
    0xcafe
    0o777

浮点数字面值
^^^^^^^^^^^^^^^^^

Acacia 中的浮点数字面值是由一个合法的十进制整数字面值，紧贴着一个 ``.`` 字符，再紧贴着一个十进制整数字面值组成的。

注意浮点数中的整数部分没有大小限制，无需控制在 32 位有符号整数范围内；但是编译器可以选择只保留一部分有效数字。

例如::

    2.345
    0.00124
    23.8

.. _str-literal:

字符串字面值
^^^^^^^^^^^^^^^^^

字符串字面值是由两个双引号 ``""`` 之间包裹着的字符内容。字符串的值就是引号之间的字符，但有以下例外，称为 :dfn:`转义`:

* ``\\`` 会被解读为反斜杠字符 ``\``。
* ``\"`` 会被解读为双引号字符 ``"``。
* ``\$`` 会被解读为美元字符 ``$``。
* ``\n`` 会被解读为换行符（LF，ASCII 码 ``0x0A``）。
* 以下转义会将输入的数字按照 Unicode 编码转换为单个字符，其中的 ``H`` 是一位十六进制数位，类似十六进制字面值，不区分大小写:

  - :samp:`\\x{HH}` 
  - :samp:`\\u{HHHH}`
  - :samp:`\\U{HHHHHHHH}`\ ，大小不超过 ``0x10FFFF``\ 。

* ``\#`` 转义生成用于给 Minecraft 中的文字设置格式的序列（详见 :mcwiki:`格式化代码`）:

  - 后面跟着非 ``(`` 字符的 ``\#`` 生成分节符号 ``§``。举例::

        "\#aBright Green\#rNormal"

  - :samp:`\\#({code})` 根据 ``code`` 指定的颜色和格式生成 Minecraft 使用的格式化代码。\ ``code`` 是由 ``,`` 字符分隔的多个格式选择词，词的两边允许空格符，但尾逗号不允许，Acacia 将会按照顺序生成各个格式选择词对应的代码字符，如 ``\#(green, bold)``\ 。

    所有可用的格式选择词及对应的 Minecraft 代码字符如下:

    ..
        Generated by Python script:
            for name, c in d.items():
                print("%-23s ``%s``          " % ("``%s``" % name, c))

    ======================= ============== ===========
    格式选择词               代码字符        含义
    ======================= ============== ===========
    ``reset``               ``r``          重置
    ``bold``                ``l``          粗体
    ``italic``              ``o``          斜体
    ``obfuscated``          ``k``          乱码
    ``black``               ``0``          黑色
    ``dark_blue``           ``1``          深蓝色
    ``dark_green``          ``2``          深绿色
    ``dark_aqua``           ``3``          深水蓝色
    ``dark_red``            ``4``          深红色
    ``dark_purple``         ``5``          深紫色
    ``gold``                ``6``          亮金色
    ``gray``                ``7``          灰色
    ``dark_gray``           ``8``          深灰色
    ``blue``                ``9``          蓝色
    ``green``               ``a``          绿色
    ``aqua``                ``b``          水蓝色
    ``red``                 ``c``          红色
    ``light_purple``        ``d``          淡紫色
    ``yellow``              ``e``          黄色
    ``white``               ``f``          白色
    ``minecoin_gold``       ``g``          硬币金色
    ======================= ============== ===========

    以下仅限 Minecraft 1.19.80 及以上:

    ======================= ============== ===========
    格式选择词               代码字符        含义
    ======================= ============== ===========
    ``material_quartz``     ``h``          石英色
    ``material_iron``       ``i``          铁色
    ``material_netherite``  ``j``          下界合金色
    ``material_redstone``   ``m``          红石色
    ``material_copper``     ``n``          铜色
    ``material_gold``       ``p``          金色
    ``material_emerald``    ``q``          绿宝石色
    ``material_diamond``    ``s``          钻石色
    ``material_lapis``      ``t``          青金石色
    ``material_amethyst``   ``u``          紫水晶色
    ======================= ============== ===========

* ``\`` 后跟的如果是一个其他字符（不是上述的任何一个情况），则编译器会报错。

字符串格式化
~~~~~~~~~~~~~~~~~

.. TODO 表达式是如何被转换的?

Acacia 允许将部分表达式在编译时转换为字符串。具体规则是，对于 :samp:`$\\{{expression}\\}`\ ，除非 ``$`` 是 ``\$`` 转义的一部分，否则编译器会将表达式 ``expression`` 转换为其字符串形式后，替换入命令内。此处表达式可以是任何合法的 Acacia 表达式，允许注释，甚至可以嵌套::

    "First ${x + "Second ${{"third"}[0]}"  #* comment *#}"

此处的 ``{}`` 之间不允许续行。

字符串字面量拼接
~~~~~~~~~~~~~~~~~

连续的两个字符串字面量（即它们中间没有任何形符）会被拼接::

    "foo" "bar"  # "foobar"
    const x = 42
    (
        # First line
        "${x}foo"
        # Second line
        "bar"
    )  # "42foobar"

注意这种拼接是发生在语法分析时而不是命令生成时的，因此仅支持拼接字符串字面量。拼接两个任意字符串类型的表达式应该使用 ``+``\ 。以下的代码是无效的::

    {"foo"}[0] "bar"  # Error: should use plus operator!


.. _command:

命令
---------------------

Acacia 允许直接指定一条要运行的命令。如果一个逻辑行中还没有产生任何一个形符，那么 ``/`` 字符将会被视为开始指令:

* ``/`` 后若不是 ``*`` 字符，则是单行命令，即读取至行末结束。
* ``/*`` 开头的是多行命令，以 ``*/`` 结束。中间的换行符会被替换为空格。

读取的指令就是读取到的字符，除了转义与格式化的部分——这些与\ :ref:`字符串的规则 <str-literal>`\ 相同。额外需要注意的是，单行命令中的 ``${}`` 不允许续行，但多行命令中的允许。


接口路径
---------------------

``interface`` 关键字被用于定义一个接口。它对语言解析的影响是: 在 ``interface`` 之后，同一逻辑行上需要紧跟以下之一（假定注释和续行已经被处理）:

* 一个\ :ref:`字符串字面量 <str-literal>`
* 由一个或多个连续的 ASCII 大小写字母、数字、\ ``.``\ 、\ ``_``\ 、\ ``-`` 或 ``/`` 字符组成的字串

解析出的字符串就是接口的路径。编译的后续阶段中会检查这些路径，以确保它们是合法的 mcfunction 路径。

示例::

    interface spam
    interface "my/path"
    const n = 10
    interface "path/(number)/${n}"
    interface a/long/long/path
    interface ---weird-.-but/__legal

接口路径解析完后，解析器会回到正常的模式解析程序的剩余部分。


运算符
---------------------

以下是 Acacia 的运算符:

.. hlist::
    :columns: 4

    * ``+``
    * ``-``
    * ``*``
    * ``/``
    * ``%``
    * ``==``
    * ``!=``
    * ``>``
    * ``>=``
    * ``<``
    * ``<=``

``/`` 和 ``*`` 也出现在命令中。\ ``*`` 也出现在多行注释中。


分隔符
---------------------

以下是 Acacia 的分隔符:

.. hlist::
    :columns: 4

    * ``(``
    * ``)``
    * ``[``
    * ``]``
    * ``{``
    * ``}``
    * ``,``
    * ``:``
    * ``.``
    * ``=``
    * ``&``
    * ``->``
    * ``:=``
    * ``+=``
    * ``-=``
    * ``*=``
    * ``/=``
    * ``%=``

``.`` 也出现在浮点数字面值里。

以下的字符在一定情况下对于词法器有特殊意义:

.. hlist::
    :columns: 4

    * ``#``
    * ``\``
    * ``"``
    * ``$``
